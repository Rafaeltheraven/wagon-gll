#![warn(missing_docs)]
//! A (pseudo) generic GLL parsing library in Rust.
//!
//! Written to supplement parsers generated by [`wagon_codegen_gll`] as a proof-of-concept for the WAGon ecosystem.
//!
//! This library could be used to write GLL parsers in another way, as long as you stick to required patterns. However,
//! the library was created with WAGs in mind. As a result, if you only care about pure GLL parsing, there
//! are probably faster implementations out there that do not have to consider the possibility of the grammar changing at runtime.
use std::{hash::{Hash, Hasher}, fmt::Debug, rc::Rc, str::from_utf8, collections::HashSet};

use self::{state::GLLState, value::Value};
use wagon_ident::Ident;

/// An implementation of the SPPF.
pub mod sppf;
/// An implementation of the global state. This is the main object that runs the parser.
pub mod state;
/// An implementation of the GSS.
pub mod gss;
mod descriptor;
/// An extension of [`wagon_codegen::value::Value`] to deal with some GLL specific elements.
pub mod value;

/// A single byte in a [`Terminal`].
pub type TerminalBit<'a> = &'a u8;
/// A Terminal, represented as a byte array.
pub type Terminal<'a> = &'a[u8];

/// The ID of the initial non-terminal.
///
/// GLL needs to have some non-terminal to start from. We define that starting non-terminal to always be `S'` and ensure that it holds.
pub const ROOT_UUID: &str = "S'";

/// A pointer to a [`Label`].
pub type GLLBlockLabel<'a> = Rc<dyn Label<'a>>;

/// The datastructure for attributes passed along as arguments.
pub type AttributeMap<'a> = Vec<Value<'a>>;
/// The datastructure for attributes returned from a non-terminal.
pub type ReturnMap<'a> = Vec<Option<Value<'a>>>;
/// The key for the [`AttributeMap`].
pub type AttributeKey = usize;

/// The main trait all elements in a GLL grammar should implement.
///
/// Every single element, both non-terminals and terminals are defined as a "Label". 
/// This trait defines methods that those labels should implement. For [`Terminal`]s, it is
/// already implemented, but non-terminals should be implemented specifically based on how they should
/// operate.
pub trait Label<'a>: Debug {
	/// Is this Label epsilon?
	fn is_eps(&self) -> bool {
		false
	}
	/// Returns the first-follow set of the label.
	///
	/// Encoded as a vector of tuples. The outer vector represents all the alternatives of this label, 
	/// while the inner vector represents all other labels that we need to check the first set from (since they may be epsilon or not).
	/// 
	/// After we have exhausted the inner vector, if the optional [`Terminal`] is not `None` then we can stop after checking whether the current
	/// character is this terminal.
	///
	/// # Example
	/// Assume we have the following rules: 
	/// ```
	/// S -> A B 'b' | B;
	/// A -> 'a';
	/// B -> 'b'
	/// ```
	/// The result of this method for S should then be:
	///
	/// `[([A, B], 'b'), ([], 'b')]`
	///
	/// # Why calculate this at runtime?
	/// The possible existence of weights makes it so that the first-follow set of any non-terminal can change at any point. 
	/// As such, we must calculate the set at runtime, depending on the context. This is the main cause of inefficiency in this library.
	///
	/// There is a possibility that this will change in the future, as the meaning of the first set in the context of WAGs is re-evaluated.
	/// But for now, it remains in it's current functional state.
	fn first_set(&self, state: &GLLState<'a>) -> Vec<(Vec<GLLBlockLabel<'a>>, Option<Terminal<'a>>)>;
	/// Any code to run when encountering this label.
	///
	/// This is called by `GLLState::goto` and is used to make the `goto` from the original paper work.
	fn code(&self, state: &mut GLLState<'a>);
	/// Check if the next token in the current state is accepted by this label's first-follow set.
	fn first(&self, state: &mut GLLState<'a>) -> bool {
		let fst = self.first_set(state);
		for (alt, fin) in fst {
			let mut check_fin = true;
			for sub in alt {
				if sub.first(state) {
					return true;
				} else if !sub.is_nullable(state, &mut HashSet::new()) {
					check_fin = false;
				    break;
				}
			}
			if check_fin {
				if let Some(last) = fin {
					return last.is_empty() || state.has_next(last)
				}
			}
		}
		false
	}
	/// Is this label a terminal?
	fn is_terminal(&self) -> bool {
		false
	}
	/// Could this label resolve to epsilon?
	fn is_nullable(&self, state: &GLLState<'a>, seen: &mut HashSet<Rc<str>>) -> bool {
		if self.is_eps() {
			true
		} else {
			let str_repr = self.uuid();
			if !seen.contains(str_repr) {
				seen.insert(str_repr.into());
				let fst = self.first_set(state);
				for (alt, _) in fst {
					if let Some(sub) = alt.into_iter().next() {
						if sub.is_nullable(state, seen) {
							return true
						}
					}
				}
			}
			false
		}
	}
	/// Optionally return the weight of this label.
	///
	/// This should either calculate the weight for this label, as denoted in the WAGon DSL, or `None`.
	fn _weight(&self, state: &GLLState<'a>) -> Option<Value<'a>>;
	/// Returns either the weight of this label as calculated by [`_weight`], or `1`.
	fn weight(&self, state: &GLLState<'a>) -> Value<'a> {
		if let Some(weight) = self._weight(state) {
			weight
		} else {
			1.into()
		}
	}
	/// A string representation of the chunk (likely a GLL block) that this label represents.
	fn to_string(&self) -> &str;
	/// The chunk represented by [`to_string`], but split by symbol into a vector.
	fn str_parts(&self) -> Vec<&str>;
	/// A unique identifier for this label.
	fn uuid(&self) -> &str;
	/// A tuple of string representations for any associated attributes.
	///
	/// The first element is a vector of all the inherited or local attributes. The second elements is a vector
	/// of all currently synthesized attributes.
	fn attr_rep_map(&self) -> (Vec<&str>, Vec<&str>);
}

impl<'a> Label<'a> for Terminal<'a> {
    fn is_eps(&self) -> bool {
        self.is_empty()
    }

    fn first_set(&self, _: &GLLState<'a>) -> Vec<(Vec<GLLBlockLabel<'a>>, Option<Terminal<'a>>)> {
        vec![(Vec::new(), Some(*self))]
    }

    fn first(&self, state: &mut GLLState<'a>) -> bool {
        self.is_eps() || state.has_next(self)
    }

    fn code(&self, _: &mut GLLState<'a>) {
        unreachable!("Should never run this method on terminals");
    }

    fn is_terminal(&self) -> bool {
        true
    }

    fn to_string(&self) -> &str {
        from_utf8(self).unwrap()
    }

    fn is_nullable(&self, _: &GLLState<'a>, _: &mut HashSet<Rc<str>>) -> bool {
        self.is_eps()
    }

    fn uuid(&self) -> &str {
        self.to_string()
    }

	fn str_parts(&self) -> Vec<&str> { 
		vec![self.to_string()]
	}

	fn attr_rep_map(&self) -> (Vec<&str>, Vec<&str>) { 
		(Vec::new(), Vec::new())
	}

	fn _weight(&self, _state: &GLLState<'a>) -> Option<Value<'a>> {
		unreachable!("Should never run this method on terminals");
	}
}

impl<'a> Hash for dyn Label<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.uuid().hash(state);
    }
}

impl<'a> PartialEq for dyn Label<'a> {
    fn eq(&self, other: &Self) -> bool {
        self.uuid() == other.uuid()
    }
}

impl<'a> Eq for dyn Label<'a>{}


#[derive(Debug)]
/// A GrammarSlot as defined by the original paper.
pub struct GrammarSlot<'a> {
	/// The non-terminal that this slot represents.
	label: GLLBlockLabel<'a>,
	/// The specific alternative of that non-terminal that this slot represents.
	rule: Rc<Vec<Ident>>,
	/// The location of the `•` inside this rule.
	dot: usize,
	/// The position of the pointer inside this rule (may be seperate from the dot)
	pos: usize,
	/// A unique identifier for this slot.
	uuid: &'a str
}

impl<'a> Eq for GrammarSlot<'a> {}

impl<'a> PartialEq for GrammarSlot<'a> {
    fn eq(&self, other: &Self) -> bool {
    	if self.is_complete() && other.is_complete() { // Any completed alt for a rule is the same except when probabilistic
    		self.label.to_string() == other.label.to_string()
    	} else {
    		self.uuid == other.uuid && self.dot == other.dot && self.pos == other.pos
    	}
    }
}

impl<'a> Hash for GrammarSlot<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
    	if self.is_complete() {
    		self.label.to_string().hash(state);
    	} else {
    		self.uuid.hash(state);
        	self.dot.hash(state);
        	self.pos.hash(state);
    	}
    }
}

impl<'a> GrammarSlot<'a> {
	/// Construct a new slot.
	pub fn new(label: GLLBlockLabel<'a>, rule: Rc<Vec<Ident>>, dot: usize, pos: usize, uuid: &'a str) -> Self {
		Self {label, rule, dot, pos, uuid}
	}

	/// Is this slot just epsilon?
	pub fn is_eps(&self) -> bool {
		self.is_empty()
	}

	/// Have we completely consumed this grammar slot?
	///
	/// This is defined as either the dot being at the end (`S -> A•`) or right before the end and the next label is epsilon (`S -> A•ε`) 
	pub fn is_last(&self, state: &GLLState<'a>) -> bool {
		self.dot == self.len() || (self.dot == self.len()-1 && self.curr_block(state).is_eps())
	}

	/// The length of the rule
	pub fn len(&self) -> usize {
		self.rule.len()
	}

	/// Whether this is an empty rule
	pub fn is_empty(&self) -> bool {
		self.len() == 0
	}

	/// A string representation of the grammar slot.
	///
	/// For example, `S -> A•B` if `self.label = S`, `self.rule = [A, B]` and `self.dot = 1`. 
	pub fn to_string(&self, state: &GLLState<'a>) -> String {
		let mut res = String::new();
		res.push_str(self.label.to_string());
		if self.dot == self.len() + 1 {
			return res
		}
		res.push_str(" -> ");
		for (i, r) in self.rule.iter().enumerate() {
			let label = state.get_label(r);
			if i == self.dot {
				let parts = label.str_parts();
				for (j, s) in parts.iter().enumerate() {
					if j == self.pos {
						res.push('•');
					}
					res.push_str(s);
				}
			} else {
				res.push_str(label.to_string());
			}
		}
		if self.is_last(state) {
			res.push('•');
		};
		res
	}

	/// Get the label for the part of the rule we are currently at as defined by the dot.
	fn curr_block(&self, state: &GLLState<'a>) -> GLLBlockLabel<'a> {
		state.get_label(&self.rule[self.dot])
	}

	/// Have we completely parsed this rule?
	///
	/// This is defined as the dot being 1 higher than the length of the rule.
	fn is_complete(&self) -> bool {
		self.dot == self.len()+1
	}

	/// Compare the weight of this slot with the weight of another.
	pub fn cmp(&self, other: &Self, state: &GLLState<'a>) -> std::cmp::Ordering {
		self.curr_block(state).weight(state).cmp(&other.curr_block(state).weight(state))
	}

	/// See [`PartialOrd`] and [`cmp`].
	pub fn partial_cmp(&self, other: &Self, state: &GLLState<'a>) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other, state))
    }
}

/// Result of the GLL parse.
pub type ParseResult<'a, T> = Result<T, GLLParseError<'a>>;

#[derive(Debug)]
/// Errors possible while GLL parsing.
pub enum GLLParseError<'a> {
	/// Encountered an unexpected byte.
	UnexpectedByte {
		/// Where in the string the byte was encountered.
		pointer: usize,
		/// What we expected to see.
		expected: u8,
		/// What we got.
		offender: u8
	},
	/// Expected more bytes than found in the input string.
	TooLong {
		/// Where we are at the input string.
		pointer: usize,
		/// What character we expected to see.
		offender: Terminal<'a>
	}
}