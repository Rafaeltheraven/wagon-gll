#![warn(missing_docs)]
//! A (pseudo) generic GLL parsing library in Rust.
//!
//! Written to supplement parsers generated by [`wagon-codegen-gll`](../wagon_codegen_gll/index.html) as a proof-of-concept for the WAGon ecosystem.
//!
//! This library could be used to write GLL parsers in another way, as long as you stick to required patterns. However,
//! the library was created with WAGs in mind. As a result, if you only care about pure GLL parsing, there
//! are probably faster implementations out there that do not have to consider the possibility of the grammar changing at runtime.
use gss::{GSSNodeIndex, GSSNode};
use petgraph::prelude::EdgeIndex;
use wagon_utils::comma_separated_with_or_str;
use std::{hash::{Hash, Hasher}, fmt::{Debug, Display}, rc::Rc, str::{from_utf8, Utf8Error}, collections::HashSet, error::Error, mem::Discriminant};

use self::{value::Value, value::InnerValueError};
use sppf::{SPPFNodeIndex, SPPFNode};
use value::ValueError;
use wagon_ident::Ident;

/// An implementation of the SPPF.
pub mod sppf;
/// An implementation of the GSS.
pub mod gss;
/// An extension of [`wagon_value::Value`] to deal with some GLL specific elements.
pub mod value;

mod label;
/// An implementation of the global state. This is the main object that runs the parser.
mod state;
mod descriptor;
mod slot;

pub use label::Label;
pub use state::GLLState;
pub use slot::GrammarSlot;

/// A single byte in a [`Terminal`].
pub type TerminalBit<'a> = &'a u8;
/// A Terminal, represented as a byte array.
pub type Terminal<'a> = &'a[u8];

/// The ID of the initial non-terminal.
///
/// GLL needs to have some non-terminal to start from. We define that starting non-terminal to always be `S'` and ensure that it holds.
pub const ROOT_UUID: &str = "S'";

/// A pointer to a [`Label`].
pub type GLLBlockLabel<'a> = Rc<dyn Label<'a>>;

/// The datastructure for attributes passed along as arguments.
pub type AttributeMap<'a> = Vec<Value<'a>>;
/// The datastructure for attributes returned from a non-terminal.
pub type ReturnMap<'a> = Vec<Option<Value<'a>>>;
/// The key for the [`AttributeMap`].
pub type AttributeKey = usize;

/// Result of the GLL parse.
pub type ParseResult<'a, T> = Result<T, GLLParseError<'a>>;

#[derive(Debug)]
/// Errors possible while GLL parsing.
pub enum GLLParseError<'a> {
	/// Encountered an unexpected byte.
	UnexpectedByte {
		/// Where in the string the byte was encountered.
		pointer: usize,
		/// What we expected to see.
		expected: u8,
		/// What we got.
		offender: u8
	},
	/// Expected more bytes than found in the input string.
	TooLong {
		/// Where we are at the input string.
		pointer: usize,
		/// What character we expected to see.
		offender: Terminal<'a>
	},
	/// Data was not utf8 compatible.
	Utf8Error(Utf8Error),
	/// A [`ValueError`] occurred during parsing.
	ValueError(ValueError<'a>),
	/// Tried to get a rule that does not exists.
	UnknownRule(&'a str),
	/// Tried to get a label that does not exist.
	UnknownLabel(&'a str),
	/// The non-terminal identified by [`ROOT_UUID`] could not be found.
	MissingRoot,
	/// An SPPF node that we expect to exist in the graph is inexplicably missing.
	MissingSPPFNode(SPPFNodeIndex),
	/// We expected a specific type of SPPF Node, but got another.
	IncorrectSPPFType(Vec<&'a str>, Discriminant<SPPFNode<'a>>),
	/// A GSS node that we expect to exist in the graph is inexplicably missing.
	MissingGSSNode(GSSNodeIndex),
	/// A GSS edge is inexplicably missing.
	MissingGSSEdge(EdgeIndex),
	/// An attribute that is expected to have been passed does not exist.
	MissingAttribute(AttributeKey, Rc<GSSNode<'a>>),
	/// An attribute that is expected to be in the context does not exist.
	MissingContext(AttributeKey, Rc<GSSNode<'a>>),
	/// Tried to do something with a completed slot
	CompletedSlot(String),
	/// Any generic fatal error for which we have no specific variant.
	Fatal(&'a str),
}

impl<'a> Display for GLLParseError<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnexpectedByte { pointer, expected, offender } => write!(f, "Encountered unexpected byte at {pointer}. Expected {expected} saw {offender}."),
            Self::TooLong { pointer, offender } => write!(f, "Tried reading more than possible from input. Current pointer at {pointer}, tried reading {offender:?}."),
            Self::Utf8Error(e) => std::fmt::Display::fmt(&e, f),
            Self::UnknownRule(s) => write!(f, "No rule with id {s} exists in the state object."),
            Self::UnknownLabel(s) => write!(f, "No label with id {s} exists in the state object."),
            Self::ValueError(e) => std::fmt::Display::fmt(&e, f),
            Self::MissingRoot => write!(f, "{ROOT_UUID} could not be found."),
            Self::MissingSPPFNode(i) => write!(f, "Expected to find SPPF node {i:?} in the graph, but it was not there."),
            Self::IncorrectSPPFType(e, c) => write!(f, "Expected SPPFNode of type {}, got {c:?}", comma_separated_with_or_str(e)),
            Self::MissingGSSNode(i) => write!(f, "Expected to find GSS node {i:?} in the graph, but it was not there."),
            Self::MissingGSSEdge(i) => write!(f, "Expected to find GSS edge {i:?} in the graph, but it was not there."),
            Self::MissingAttribute(i, g) => write!(f, "The {i}th attribute is not at GSS node {g:?}"),
            Self::MissingContext(i, g) => write!(f, "The {i}th attribute is not in the context of GSS node {g:?}"),
            Self::CompletedSlot(s) => write!(f, "Tried to access completed slot {s} as if it were not completed."),
            Self::Fatal(s) => write!(f, "A fatal error occurred! {s}."),
        }
    }
}

impl Error for GLLParseError<'static> {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            Self::ValueError(e) => Some(e),
            Self::Utf8Error(e) => Some(e),
            _ => None
        }
    }
}

impl<'a> From<ValueError<'a>> for GLLParseError<'a> {
    fn from(value: ValueError<'a>) -> Self {
        Self::ValueError(value)
    }
}

impl<'a> From<Utf8Error> for GLLParseError<'a> {
    fn from(value: Utf8Error) -> Self {
        Self::Utf8Error(value)
    }
}

/// Result type for any operations on the finished state that can error.
pub type ProcessResult<T> = Result<T, GLLProcessError>;

/// Errors that can occur when processing the finished state object.
#[derive(Debug)]
pub enum GLLProcessError {
	/// An SPPF node that we expect to exist in the graph is inexplicably missing.
	MissingSPPFNode(SPPFNodeIndex),
}

impl Display for GLLProcessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
        	Self::MissingSPPFNode(i) => write!(f, "Expected to find SPPF node {i:?} in the graph, but it was not there."),
        }
    }
}

impl Error for GLLProcessError {}